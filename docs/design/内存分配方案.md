# 内存分配方案

## 需求确定

1. 需要支持内存对齐
1. 需要性能尽可能好
1. 需要支持线程安全
1. 需要具备调试能力
1. 需要支持多种分配策略
1. 需要易于使用，易于维护，可读性好
1. 需要预留一定跨平台和扩展能力

## 方案

经过调研, 决定采取自实现内存池，并且内存分配直接调用系统原生api(带内存对齐)，未来如果要换内存分配器，也可以随时改api即可

备选方案:
* mimalloc: 微软出品，虚幻引擎也在用，声称性能大于jemalloc, tcmalloc等内存分配库
  * 有网友提到，性能不一定比系统原生内存分配好，故实际情况待测试
  * rust的某个issue里的benchmark提到，比jemalloc性能实际差距不大且占用内存更多一点，故rust没有切换mimalloc
* std:;pmr自实现内存池(可实现运行时多态内存资源，但是当前没那么灵活的需求, 而且里面有虚函数调用和指针的额外开销，还得适配容器)

## 内存对齐的支持

1. C++需要17+
    - 需要over-aligned的保障机制: 比如alignas, 带align参数的new等
2. 分配器可支持对齐参数

## 分配器设计

1. 主类采用类模板实现多态，模板参数代表了分配器的策略，每种策略对应了一种类，这样可以避免虚函数开销
  * 策略包括：线程安全，是否调试，内存区，分配器算法的选择
1. 具体的分配算法与内存区是解耦的，分配器本身无状态，只需传入内存区的内存起止位置即可
1. 策略包内的策略扩展性很灵活，方便未来扩展
1. 底层分配调用目前根据平台做出区分，原生支持内存对齐操作,如果未来要改分配器，也很方便修改代码

## 参考

由于没对网址做记录，此处只列出关键词

1. cpp renference: memory management
1. windows api: _aligned_malloc, over-aligned support 
1. google-filament:allocator
1. github: mimalloc
1. C++17 Complete Guide: chapter29/30: std::pmr, over-aligned data
1. cppcon2019: pratical memory allocator
1. modernescpp: std::pmr
1. 多个内存管理和分配的中文博客或文章

